{"prompt": "Write a SystemVerilog Assertion to check ALU overflow flag after addition.", "completion": "property p_alu_overflow_after_add;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == ADD && (src_a + src_b > 8'hFF)) |-> overflow_flag;\nendproperty\n\nassert property (p_alu_overflow_after_add)\nelse $error(\"Error: Overflow flag not set after addition in ALU\");"}
{"prompt": "Write a SystemVerilog Assertion to check zero flag after subtraction.", "completion": "property p_zero_flag_after_sub;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == SUB && (src_a - src_b == 0)) |-> zero_flag;\nendproperty\n\nassert property (p_zero_flag_after_sub)\nelse $error(\"Error: Zero flag not set after subtraction in ALU\");"}
{"prompt": "Write a SystemVerilog Assertion to check carry flag after addition.", "completion": "property p_carry_flag_after_add;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == ADD && (src_a + src_b) > 8'hFF) |-> carry_flag;\nendproperty\n\nassert property (p_carry_flag_after_add)\nelse $error(\"Error: Carry flag not set correctly after addition in ALU\");"}
{"prompt": "Write a SystemVerilog Assertion to check ALU result for AND operation.", "completion": "property p_alu_result_and;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == AND) |-> (alu_result == (src_a & src_b));\nendproperty\n\nassert property (p_alu_result_and)\nelse $error(\"Error: ALU result incorrect for AND operation\");"}
{"prompt": "Write a SystemVerilog Assertion to check ALU result for OR operation.", "completion": "property p_alu_result_or;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == OR) |-> (alu_result == (src_a | src_b));\nendproperty\n\nassert property (p_alu_result_or)\nelse $error(\"Error: ALU result incorrect for OR operation\");"}
{"prompt": "Write a SystemVerilog Assertion to check ALU result for XOR operation.", "completion": "property p_alu_result_xor;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == XOR) |-> (alu_result == (src_a ^ src_b));\nendproperty\n\nassert property (p_alu_result_xor)\nelse $error(\"Error: ALU result incorrect for XOR operation\");"}
{"prompt": "Write a SystemVerilog Assertion to check ALU result remains stable when enable=0.", "completion": "property p_alu_result_stable_when_disabled;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (!alu_enable) |-> $stable(alu_result);\nendproperty\n\nassert property (p_alu_result_stable_when_disabled)\nelse $error(\"Error: ALU result changed while ALU disabled\");"}
{"prompt": "Write a SystemVerilog Assertion to check negative flag for subtraction.", "completion": "property p_negative_flag_after_sub;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (alu_op == SUB && (src_a < src_b)) |-> negative_flag;\nendproperty\n\nassert property (p_negative_flag_after_sub)\nelse $error(\"Error: Negative flag not set when result is negative\");"}
{"prompt": "Write a SystemVerilog Assertion to verify D-FF captures input on rising edge of clock.", "completion": "property p_dff_capture_on_clock;\n    @(posedge clk)\n    disable iff (!rst_n)\n    d |-> (q == d);\nendproperty\n\nassert property (p_dff_capture_on_clock)\nelse $error(\"Error: D-FF did not capture input on clock edge\");"}
{"prompt": "Write a SystemVerilog Assertion to verify D-FF holds value when enable=0.", "completion": "property p_dff_hold_when_disabled;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (!enable) |-> $stable(q);\nendproperty\n\nassert property (p_dff_hold_when_disabled)\nelse $error(\"Error: D-FF output changed when enable=0\");"}
{"prompt": "Write a SystemVerilog Assertion to check asynchronous reset clears output.", "completion": "property p_dff_async_reset;\n    @(posedge clk or negedge rst_n)\n    (!rst_n) |-> (q == 0);\nendproperty\n\nassert property (p_dff_async_reset)\nelse $error(\"Error: D-FF output not cleared during reset\");"}
{"prompt": "Write a SystemVerilog Assertion to verify that output changes only on clock edge.", "completion": "property p_dff_output_on_clock_only;\n    @(posedge clk)\n    disable iff (!rst_n)\n    $changed(q) |-> $rose(clk);\nendproperty\n\nassert property (p_dff_output_on_clock_only)\nelse $error(\"Error: D-FF output changed without clock edge\");"}
{"prompt": "Write a SystemVerilog Assertion to verify BCD increment by 1.", "completion": "property p_bcd_increment;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (enable && inc_dec == 1) |-> (bcd_out == bcd_in + 1);\nendproperty\n\nassert property (p_bcd_increment)\nelse $error(\"Error: BCD increment failed\");"}
{"prompt": "Write a SystemVerilog Assertion to verify BCD decrement by 1.", "completion": "property p_bcd_decrement;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (enable && inc_dec == 0) |-> (bcd_out == bcd_in - 1);\nendproperty\n\nassert property (p_bcd_decrement)\nelse $error(\"Error: BCD decrement failed\");"}
{"prompt": "Write a SystemVerilog Assertion to check BCD reset sets output to zero.", "completion": "property p_bcd_reset;\n    @(posedge clk or negedge rst_n)\n    (!rst_n) |-> (bcd_out == 12'd0);\nendproperty\n\nassert property (p_bcd_reset)\nelse $error(\"Error: BCD counter did not reset correctly\");"}
{"prompt": "Write a SystemVerilog Assertion to verify BCD output stays stable when enable=0.", "completion": "property p_bcd_stable_when_disabled;\n    @(posedge clk)\n    disable iff (!rst_n)\n    (!enable) |-> $stable(bcd_out);\nendproperty\n\nassert property (p_bcd_stable_when_disabled)\nelse $error(\"Error: BCD output changed while disabled\");"}
{"prompt": "Write SystemVerilog code for a 4-bit ALU with ADD, SUB, AND, OR, XOR operations and generate SVA checks for overflow and result correctness.", "completion": "module alu_4bit(\n    input  logic [3:0] a, b,\n    input  logic [2:0] alu_op,\n    output logic [3:0] result,\n    output logic overflow_flag\n);\n    always_comb begin\n        overflow_flag = 0;\n        case(alu_op)\n            3'b000: {overflow_flag, result} = a + b;    // ADD\n            3'b001: {overflow_flag, result} = a - b;    // SUB\n            3'b010: result = a & b;                     // AND\n            3'b011: result = a | b;                     // OR\n            3'b100: result = a ^ b;                     // XOR\n            default: result = 4'd0;\n        endcase\n    end\nendmodule\n\n// Assertions\nproperty p_overflow_after_add;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b000 && (a + b > 4'hF)) |-> overflow_flag;\nendproperty\nassert property (p_overflow_after_add);\n\nproperty p_alu_result_and;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b010) |-> (result == (a & b));\nendproperty\nassert property (p_alu_result_and);"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU with ADD, SUB, AND, OR, XOR operations and generate SVA checks for overflow, zero flag, and result correctness.", "completion": "module alu_8bit(\n    input  logic [7:0] a, b,\n    input  logic [2:0] alu_op,\n    output logic [7:0] result,\n    output logic overflow_flag, zero_flag\n);\n    always_comb begin\n        overflow_flag = 0; zero_flag = 0;\n        case(alu_op)\n            3'b000: {overflow_flag, result} = a + b;    // ADD\n            3'b001: {overflow_flag, result} = a - b;    // SUB\n            3'b010: result = a & b;                     // AND\n            3'b011: result = a | b;                     // OR\n            3'b100: result = a ^ b;                     // XOR\n            default: result = 8'd0;\n        endcase\n        if(result == 8'd0) zero_flag = 1;\n    end\nendmodule\n\n// Assertions\nproperty p_overflow_after_add;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b000 && (a + b > 8'hFF)) |-> overflow_flag;\nendproperty\nassert property (p_overflow_after_add);\n\nproperty p_zero_flag_after_sub;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b001 && (a - b == 0)) |-> zero_flag;\nendproperty\nassert property (p_zero_flag_after_sub);\n\nproperty p_alu_result_or;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b011) |-> (result == (a | b));\nendproperty\nassert property (p_alu_result_or);"}
{"prompt": "Write SystemVerilog code for a 16-bit ALU with ADD, SUB, AND, OR, XOR operations and generate SVA checks for overflow and result correctness.", "completion": "module alu_16bit(\n    input  logic [15:0] a, b,\n    input  logic [2:0] alu_op,\n    output logic [15:0] result,\n    output logic overflow_flag\n);\n    always_comb begin\n        overflow_flag = 0;\n        case(alu_op)\n            3'b000: {overflow_flag, result} = a + b;    // ADD\n            3'b001: {overflow_flag, result} = a - b;    // SUB\n            3'b010: result = a & b;                     // AND\n            3'b011: result = a | b;                     // OR\n            3'b100: result = a ^ b;                     // XOR\n            default: result = 16'd0;\n        endcase\n    end\nendmodule\n\n// Assertions\nproperty p_overflow_after_add;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b000 && (a + b > 16'hFFFF)) |-> overflow_flag;\nendproperty\nassert property (p_overflow_after_add);\n\nproperty p_alu_result_xor;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b100) |-> (result == (a ^ b));\nendproperty\nassert property (p_alu_result_xor);"}
{"prompt": "Write SystemVerilog code for a 32-bit ALU with ADD, SUB, AND, OR, XOR operations and generate SVA checks for overflow and result correctness.", "completion": "module alu_32bit(\n    input  logic [31:0] a, b,\n    input  logic [2:0] alu_op,\n    output logic [31:0] result,\n    output logic overflow_flag\n);\n    always_comb begin\n        overflow_flag = 0;\n        case(alu_op)\n            3'b000: {overflow_flag, result} = a + b;    // ADD\n            3'b001: {overflow_flag, result} = a - b;    // SUB\n            3'b010: result = a & b;                     // AND\n            3'b011: result = a | b;                     // OR\n            3'b100: result = a ^ b;                     // XOR\n            default: result = 32'd0;\n        endcase\n    end\nendmodule\n\n// Assertions\nproperty p_overflow_after_add;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b000 && (a + b > 32'hFFFFFFFF)) |-> overflow_flag;\nendproperty\nassert property (p_overflow_after_add);\n\nproperty p_alu_result_and;\n    @(posedge clk) disable iff (!rst_n)\n    (alu_op == 3'b010) |-> (result == (a & b));\nendproperty\nassert property (p_alu_result_and);"}
{"prompt": "Write SystemVerilog code for a positive-edge triggered D flip-flop with synchronous reset and include SVA checks.", "completion": "module dff_sync(input logic clk, reset, d, output logic q);\nalways_ff @(posedge clk) begin\n    if (reset)\n        q <= 0;\n    else\n        q <= d;\nend\nendmodule\n\n// SVA Checks\nproperty p_sync_reset;\n    @(posedge clk) disable iff (!reset)\n    reset |-> (q == 0);\nendproperty\nassert property(p_sync_reset);\n\nproperty p_d_capture;\n    @(posedge clk) disable iff (reset)\n    d |-> q == d;\nendproperty\nassert property(p_d_capture);"}
{"prompt": "Write SystemVerilog code for a positive-edge triggered D flip-flop with asynchronous reset and include SVA checks.", "completion": "module dff_async(input logic clk, reset, d, output logic q);\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset)\n        q <= 0;\n    else\n        q <= d;\nend\nendmodule\n\n// SVA Checks\nproperty p_async_reset;\n    @(posedge clk) disable iff (!reset)\n    reset |-> (q == 0);\nendproperty\nassert property(p_async_reset);\n\nproperty p_d_capture;\n    @(posedge clk) disable iff (reset)\n    d |-> q == d;\nendproperty\nassert property(p_d_capture);"}
{"prompt": "Write SystemVerilog code for a D flip-flop with enable and synchronous reset and include SVA checks.", "completion": "module dff_enable(input logic clk, reset, en, d, output logic q);\nalways_ff @(posedge clk) begin\n    if (reset)\n        q <= 0;\n    else if (en)\n        q <= d;\nend\nendmodule\n\n// SVA Checks\nproperty p_sync_reset;\n    @(posedge clk) disable iff (!reset)\n    reset |-> (q == 0);\nendproperty\nassert property(p_sync_reset);\n\nproperty p_enable_d_capture;\n    @(posedge clk) disable iff (reset)\n    en |-> (q == d);\nendproperty\nassert property(p_enable_d_capture);"}
{"prompt": "Write SystemVerilog code for a negative-edge triggered D flip-flop with asynchronous reset and include SVA checks.", "completion": "module dff_neg_async(input logic clk, reset, d, output logic q);\nalways_ff @(negedge clk or posedge reset) begin\n    if (reset)\n        q <= 0;\n    else\n        q <= d;\nend\nendmodule\n\n// SVA Checks\nproperty p_async_reset;\n    @(negedge clk) disable iff (!reset)\n    reset |-> (q == 0);\nendproperty\nassert property(p_async_reset);\n\nproperty p_d_capture;\n    @(negedge clk) disable iff (reset)\n    d |-> q == d;\nendproperty\nassert property(p_d_capture);"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and include SVA checks for correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    if (bcd_in == 12'd999)\n        bcd_out = 12'd0;\n    else\n        bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA Checks\nproperty p_bcd_increment;\n    @(posedge clk) disable iff (!reset_n)\n    (bcd_in < 12'd999) |-> (bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(p_bcd_increment);\n\nproperty p_bcd_wraparound;\n    @(posedge clk) disable iff (!reset_n)\n    (bcd_in == 12'd999) |-> (bcd_out == 12'd0);\nendproperty\nassert property(p_bcd_wraparound);"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and include SVA checks for correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    if (bcd_in == 12'd0)\n        bcd_out = 12'd999;\n    else\n        bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA Checks\nproperty p_bcd_decrement;\n    @(posedge clk) disable iff (!reset_n)\n    (bcd_in > 12'd0) |-> (bcd_out == bcd_in - 12'd1);\n"}
