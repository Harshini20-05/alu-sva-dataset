{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing ADD and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing XOR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check no metastability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for no metastability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing SUB and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check data stability.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for data stability\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a D flip-flop and generate an SVA to check reset behavior.", "completion": "module dff(input logic clk, reset_n, d, output logic q);\nalways_ff @(posedge clk or negedge reset_n)\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nendmodule\n\n// SVA for reset behavior\nproperty dff_check;\n    @(posedge clk) disable iff (!reset_n)\n        (d |-> q == d);\nendproperty\nassert property(dff_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD incrementer and generate an SVA to verify output correctness.", "completion": "module bcd_increment(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in + 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_increment_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in + 12'd1);\nendproperty\nassert property(bcd_increment_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing AND and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for an 8-bit ALU performing OR and generate an SVA to verify overflow flag.", "completion": "module alu_8bit(input logic [7:0] a, b, input logic [2:0] op, output logic [7:0] result, output logic overflow);\nalways_comb begin\n    case(op)\n        3'b000: {overflow, result} = a + b;\n        3'b001: {overflow, result} = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        default: result = 8'h00;\n    endcase\nend\nendmodule\n\n// SVA for overflow\nproperty overflow_check;\n    @(posedge clk) disable iff (!reset_n)\n        (op == 3'b000 |-> overflow == ((a + b) > 8'hFF));\nendproperty\nassert property(overflow_check);\n"}
{"prompt": "Write SystemVerilog code for a 3-digit BCD decrementer and generate an SVA to verify output correctness.", "completion": "module bcd_decrement(input logic [11:0] bcd_in, output logic [11:0] bcd_out);\nalways_comb begin\n    bcd_out = bcd_in - 12'd1;\nend\nendmodule\n\n// SVA for correctness\nproperty bcd_decrement_check;\n    @(posedge clk) disable iff (!reset_n)\n        (1'b1 |-> bcd_out == bcd_in - 12'd1);\nendproperty\nassert property(bcd_decrement_check);\n"}
